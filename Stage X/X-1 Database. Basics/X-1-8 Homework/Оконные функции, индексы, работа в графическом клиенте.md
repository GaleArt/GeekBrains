          Базы данных. Основы
      Оконные функции, индексы, работа в графическом клиенте

      ДОМАШНЕЕ ЗАДАНИЕ:
      Работаем с базой данных учителей teachers.db. Для каждого задания требуется сдать только код,
  который выполняется для получения результата, в текстовом файле. В качестве отчёта к четвёртому
  заданию надо приложить скриншот.
1. Найдите общее количество учеников для каждого курса. В отчёт выведите название курса и количество
учеников по всем потокам курса. Решите задание с применением оконных функций.
2. Найдите среднюю оценку по всем потокам для всех учителей. В отчёт выведите идентификатор, фамилию и имя учителя,
среднюю оценку по всем проведённым потокам. Учителя, у которых не было потоков, также должны попасть в выборку.
Решите задание с применением оконных функций.
3. Какие индексы надо создать для максимально быстрого выполнения представленного запроса?

SELECT
  surname,
  name,
  number,
  performance
FROM academic_performance
  JOIN teachers
    ON academic_performance.teacher_id = teachers.id
  JOIN streams
    ON academic_performance.stream_id = streams.id
WHERE number >= 200;

4. Установите SQLiteStudio, подключите базу данных учителей, выполните в графическом клиенте любой запрос.
5. Дополнительное задание. Для каждого преподавателя выведите имя, фамилию, минимальное значение успеваемости
по всем потокам преподавателя, название курса, который соответствует потоку с минимальным значением успеваемости, максимальное
значение успеваемости по всем потокам преподавателя, название курса, соответствующий потоку с максимальным значением успеваемости.
Выполните задачу с использованием оконных функций.

Комментарии к домашкам:
      Homework X-1-2
    Кирилл Иванов (Наставник)
Таблицы есть, первичные ключи есть, внешние ключи есть. Всё на месте.
Хорошо, что не забыли про составной первичный ключ в таблице успеваемоти студентов.
Здорово, что придерживаетесь принятого в SQL стиля оформления кода (зарезервированные слова в верхнем регистре, форматирование кода...)!
Комплексный список рекомендаций по оформлению SQL-кода можно найти, например, тут: https://www.sqlstyle.guide/ru/ .
Хорошо, что заполнили таблицы данными, но по заданию этого не требовалось.
      Homework X-1-3
    Кирилл Иванов (Наставник)
Обе команды ALTER TABLE есть. Все хорошо.
Вставку нескольких записей лучше делать пакетной (одной командной вставлять несколько строк). Это положительно влияет на производительность.
SQL-код принято оформлять в текстовых файлах (скриптах) с расширением *.sql
Официальная документация по команде ALTER TABLE в SQLite: https://www.sqlite.org/lang_altertable.html
      Homework X-1-5
    Кирилл Иванов (наставник)
Вложенные во вложенные запросы работают неэффективно (медленно). Лучше стараться избегать таких конструкций.
Весь текст, кроме SQL-кода, в присылаемых скриптах лучше сразу оформлять внутри комментариев, чтобы сам скрипт
можно было запустить целиком без дополнительного редактирования. Так в целом принято в индустрии.
  https://zametkinapolyah.ru/zametki-o-mysql/chast-2-1-sql-kommentarii-v-bazax-dannyx-sqlite.html
Тема вложенных запросов и объединения UNION усвоена.
      Homework X-1-6
    Кирилл Иванов (наставник)
Псевдонимы для имен таблиц - удобная фича. Ее можно использовать также с ключевым словом AS после имени таблицы в запросе. Это сокращает текст запроса и улучшает его читабельность.
Хорошо, что смогли обойтись без вложенных запросов. Не у всех это получилось.
Есть смысл внутреннее объединение таблиц всегда записывать в полном синтаксисе (INNER JOIN вместо JOIN). Так код становится более очевидным.
      Homework X-1-7
    Кирилл Иванов (наставник)
Обратите внимание, что Ваш триггер будет срабатывать только на событие вставки данных. Но данные можно изменить и путем обновления существующей строки. На этот случай нужно писать еще один триггер на соответствующее событие.
Перед созданием представления для лучшей отказоустойчивости кода есть смысл проверить: нет ли в БД уже представления с таким именем и удалить его. Это можно реализовать конструкцией DROP VIEW IF EXISTS… https://www.sqlitetutorial.net/sqlite-drop-view/
Правильно, что внутри транзакции не забыли удалить данные из разных таблиц, а не только из одной.
Для более продвинутого управления транзакциями можно использовать SAVEPOINT. Если есть интерес, можете ознакомиться по ссылке: https://www.sqlite.org/lang_savepoint.html
